{
  "version": 3,
  "sources": ["../../three/examples/jsm/modifiers/SimplifyModifier.js"],
  "sourcesContent": ["import {\r\n\tBufferGeometry,\r\n\tFloat32BufferAttribute,\r\n\tVector2,\r\n\tVector3,\r\n\tVector4\r\n} from 'three';\r\nimport * as BufferGeometryUtils from '../utils/BufferGeometryUtils.js';\r\n\r\n/**\r\n *\tSimplification Geometry Modifier\r\n *    - based on code and technique\r\n *\t  - by Stan Melax in 1998\r\n *\t  - Progressive Mesh type Polygon Reduction Algorithm\r\n *    - http://www.melax.com/polychop/\r\n */\r\n\r\nconst _cb = new Vector3(), _ab = new Vector3();\r\n\r\nclass SimplifyModifier {\r\n\r\n\tmodify( geometry, count ) {\r\n\r\n\t\tgeometry = geometry.clone();\r\n\r\n\t\t// currently morphAttributes are not supported\r\n\t\tdelete geometry.morphAttributes.position;\r\n\t\tdelete geometry.morphAttributes.normal;\r\n\t\tconst attributes = geometry.attributes;\r\n\r\n\t\t// this modifier can only process indexed and non-indexed geomtries with at least a position attribute\r\n\r\n\t\tfor ( const name in attributes ) {\r\n\r\n\t\t\tif ( name !== 'position' && name !== 'uv' && name !== 'normal' && name !== 'tangent' && name !== 'color' ) geometry.deleteAttribute( name );\r\n\r\n\t\t}\r\n\r\n\t\tgeometry = BufferGeometryUtils.mergeVertices( geometry );\r\n\r\n\t\t//\r\n\t\t// put data of original geometry in different data structures\r\n\t\t//\r\n\r\n\t\tconst vertices = [];\r\n\t\tconst faces = [];\r\n\r\n\t\t// add vertices\r\n\r\n\t\tconst positionAttribute = geometry.getAttribute( 'position' );\r\n\t\tconst uvAttribute = geometry.getAttribute( 'uv' );\r\n\t\tconst normalAttribute = geometry.getAttribute( 'normal' );\r\n\t\tconst tangentAttribute = geometry.getAttribute( 'tangent' );\r\n\t\tconst colorAttribute = geometry.getAttribute( 'color' );\r\n\r\n\t\tlet t = null;\r\n\t\tlet v2 = null;\r\n\t\tlet nor = null;\r\n\t\tlet col = null;\r\n\r\n\t\tfor ( let i = 0; i < positionAttribute.count; i ++ ) {\r\n\r\n\t\t\tconst v = new Vector3().fromBufferAttribute( positionAttribute, i );\r\n\t\t\tif ( uvAttribute ) {\r\n\r\n\t\t\t\tv2 = new Vector2().fromBufferAttribute( uvAttribute, i );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( normalAttribute ) {\r\n\r\n\t\t\t\tnor = new Vector3().fromBufferAttribute( normalAttribute, i );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( tangentAttribute ) {\r\n\r\n\t\t\t\tt = new Vector4().fromBufferAttribute( tangentAttribute, i );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( colorAttribute ) {\r\n\r\n\t\t\t\tcol = new THREE.Color().fromBufferAttribute( colorAttribute, i );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tconst vertex = new Vertex( v, v2, nor, t, col );\r\n\t\t\tvertices.push( vertex );\r\n\r\n\t\t}\r\n\r\n\t\t// add faces\r\n\r\n\t\tlet index = geometry.getIndex();\r\n\r\n\t\tif ( index !== null ) {\r\n\r\n\t\t\tfor ( let i = 0; i < index.count; i += 3 ) {\r\n\r\n\t\t\t\tconst a = index.getX( i );\r\n\t\t\t\tconst b = index.getX( i + 1 );\r\n\t\t\t\tconst c = index.getX( i + 2 );\r\n\r\n\t\t\t\tconst triangle = new Triangle( vertices[ a ], vertices[ b ], vertices[ c ], a, b, c );\r\n\t\t\t\tfaces.push( triangle );\r\n\r\n\t\t\t}\r\n\r\n\t\t} else {\r\n\r\n\t\t\tfor ( let i = 0; i < positionAttribute.count; i += 3 ) {\r\n\r\n\t\t\t\tconst a = i;\r\n\t\t\t\tconst b = i + 1;\r\n\t\t\t\tconst c = i + 2;\r\n\r\n\t\t\t\tconst triangle = new Triangle( vertices[ a ], vertices[ b ], vertices[ c ], a, b, c );\r\n\t\t\t\tfaces.push( triangle );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\t// compute all edge collapse costs\r\n\r\n\t\tfor ( let i = 0, il = vertices.length; i < il; i ++ ) {\r\n\r\n\t\t\tcomputeEdgeCostAtVertex( vertices[ i ] );\r\n\r\n\t\t}\r\n\r\n\t\tlet nextVertex;\r\n\r\n\t\tlet z = count;\r\n\r\n\t\twhile ( z -- ) {\r\n\r\n\t\t\tnextVertex = minimumCostEdge( vertices );\r\n\r\n\t\t\tif ( ! nextVertex ) {\r\n\r\n\t\t\t\tconsole.log( 'THREE.SimplifyModifier: No next vertex' );\r\n\t\t\t\tbreak;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tcollapse( vertices, faces, nextVertex, nextVertex.collapseNeighbor );\r\n\r\n\t\t}\r\n\r\n\t\t//\r\n\r\n\t\tconst simplifiedGeometry = new BufferGeometry();\r\n\t\tconst position = [];\r\n\t\tconst uv = [];\r\n\t\tconst normal = [];\r\n\t\tconst tangent = [];\r\n\t\tconst color = [];\r\n\r\n\t\tindex = [];\r\n\r\n\t\t//\r\n\r\n\t\tfor ( let i = 0; i < vertices.length; i ++ ) {\r\n\r\n\t\t\tconst vertex = vertices[ i ];\r\n\t\t\tposition.push( vertex.position.x, vertex.position.y, vertex.position.z );\r\n\t\t\tif ( vertex.uv ) {\r\n\r\n\t\t\t\tuv.push( vertex.uv.x, vertex.uv.y );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( vertex.normal ) {\r\n\r\n\t\t\t\tnormal.push( vertex.normal.x, vertex.normal.y, vertex.normal.z );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( vertex.tangent ) {\r\n\r\n\t\t\t\ttangent.push( vertex.tangent.x, vertex.tangent.y, vertex.tangent.z, vertex.tangent.w );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( vertex.color ) {\r\n\r\n\t\t\t\tcolor.push( vertex.color.r, vertex.color.g, vertex.color.b );\r\n\r\n\t\t\t}\r\n\r\n\r\n\t\t\t// cache final index to GREATLY speed up faces reconstruction\r\n\t\t\tvertex.id = i;\r\n\r\n\t\t}\r\n\r\n\t\t//\r\n\r\n\t\tfor ( let i = 0; i < faces.length; i ++ ) {\r\n\r\n\t\t\tconst face = faces[ i ];\r\n\t\t\tindex.push( face.v1.id, face.v2.id, face.v3.id );\r\n\r\n\t\t}\r\n\r\n\t\tsimplifiedGeometry.setAttribute( 'position', new Float32BufferAttribute( position, 3 ) );\r\n\t\tif ( uv.length > 0 ) simplifiedGeometry.setAttribute( 'uv', new Float32BufferAttribute( uv, 2 ) );\r\n\t\tif ( normal.length > 0 ) simplifiedGeometry.setAttribute( 'normal', new Float32BufferAttribute( normal, 3 ) );\r\n\t\tif ( tangent.length > 0 ) simplifiedGeometry.setAttribute( 'tangent', new Float32BufferAttribute( tangent, 4 ) );\r\n\t\tif ( color.length > 0 ) simplifiedGeometry.setAttribute( 'color', new Float32BufferAttribute( color, 3 ) );\r\n\r\n\t\tsimplifiedGeometry.setIndex( index );\r\n\r\n\t\treturn simplifiedGeometry;\r\n\r\n\t}\r\n\r\n}\r\n\r\nfunction pushIfUnique( array, object ) {\r\n\r\n\tif ( array.indexOf( object ) === - 1 ) array.push( object );\r\n\r\n}\r\n\r\nfunction removeFromArray( array, object ) {\r\n\r\n\tconst k = array.indexOf( object );\r\n\tif ( k > - 1 ) array.splice( k, 1 );\r\n\r\n}\r\n\r\nfunction computeEdgeCollapseCost( u, v ) {\r\n\r\n\t// if we collapse edge uv by moving u to v then how\r\n\t// much different will the model change, i.e. the \"error\".\r\n\r\n\tconst edgelength = v.position.distanceTo( u.position );\r\n\tlet curvature = 0;\r\n\r\n\tconst sideFaces = [];\r\n\r\n\t// find the \"sides\" triangles that are on the edge uv\r\n\tfor ( let i = 0, il = u.faces.length; i < il; i ++ ) {\r\n\r\n\t\tconst face = u.faces[ i ];\r\n\r\n\t\tif ( face.hasVertex( v ) ) {\r\n\r\n\t\t\tsideFaces.push( face );\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\t// use the triangle facing most away from the sides\r\n\t// to determine our curvature term\r\n\tfor ( let i = 0, il = u.faces.length; i < il; i ++ ) {\r\n\r\n\t\tlet minCurvature = 1;\r\n\t\tconst face = u.faces[ i ];\r\n\r\n\t\tfor ( let j = 0; j < sideFaces.length; j ++ ) {\r\n\r\n\t\t\tconst sideFace = sideFaces[ j ];\r\n\t\t\t// use dot product of face normals.\r\n\t\t\tconst dotProd = face.normal.dot( sideFace.normal );\r\n\t\t\tminCurvature = Math.min( minCurvature, ( 1.001 - dotProd ) / 2 );\r\n\r\n\t\t}\r\n\r\n\t\tcurvature = Math.max( curvature, minCurvature );\r\n\r\n\t}\r\n\r\n\t// crude approach in attempt to preserve borders\r\n\t// though it seems not to be totally correct\r\n\tconst borders = 0;\r\n\r\n\tif ( sideFaces.length < 2 ) {\r\n\r\n\t\t// we add some arbitrary cost for borders,\r\n\t\t// borders += 10;\r\n\t\tcurvature = 1;\r\n\r\n\t}\r\n\r\n\tconst amt = edgelength * curvature + borders;\r\n\r\n\treturn amt;\r\n\r\n}\r\n\r\nfunction computeEdgeCostAtVertex( v ) {\r\n\r\n\t// compute the edge collapse cost for all edges that start\r\n\t// from vertex v.  Since we are only interested in reducing\r\n\t// the object by selecting the min cost edge at each step, we\r\n\t// only cache the cost of the least cost edge at this vertex\r\n\t// (in member variable collapse) as well as the value of the\r\n\t// cost (in member variable collapseCost).\r\n\r\n\tif ( v.neighbors.length === 0 ) {\r\n\r\n\t\t// collapse if no neighbors.\r\n\t\tv.collapseNeighbor = null;\r\n\t\tv.collapseCost = - 0.01;\r\n\r\n\t\treturn;\r\n\r\n\t}\r\n\r\n\tv.collapseCost = 100000;\r\n\tv.collapseNeighbor = null;\r\n\r\n\t// search all neighboring edges for \"least cost\" edge\r\n\tfor ( let i = 0; i < v.neighbors.length; i ++ ) {\r\n\r\n\t\tconst collapseCost = computeEdgeCollapseCost( v, v.neighbors[ i ] );\r\n\r\n\t\tif ( ! v.collapseNeighbor ) {\r\n\r\n\t\t\tv.collapseNeighbor = v.neighbors[ i ];\r\n\t\t\tv.collapseCost = collapseCost;\r\n\t\t\tv.minCost = collapseCost;\r\n\t\t\tv.totalCost = 0;\r\n\t\t\tv.costCount = 0;\r\n\r\n\t\t}\r\n\r\n\t\tv.costCount ++;\r\n\t\tv.totalCost += collapseCost;\r\n\r\n\t\tif ( collapseCost < v.minCost ) {\r\n\r\n\t\t\tv.collapseNeighbor = v.neighbors[ i ];\r\n\t\t\tv.minCost = collapseCost;\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\t// we average the cost of collapsing at this vertex\r\n\tv.collapseCost = v.totalCost / v.costCount;\r\n\t// v.collapseCost = v.minCost;\r\n\r\n}\r\n\r\nfunction removeVertex( v, vertices ) {\r\n\r\n\tconsole.assert( v.faces.length === 0 );\r\n\r\n\twhile ( v.neighbors.length ) {\r\n\r\n\t\tconst n = v.neighbors.pop();\r\n\t\tremoveFromArray( n.neighbors, v );\r\n\r\n\t}\r\n\r\n\tremoveFromArray( vertices, v );\r\n\r\n}\r\n\r\nfunction removeFace( f, faces ) {\r\n\r\n\tremoveFromArray( faces, f );\r\n\r\n\tif ( f.v1 ) removeFromArray( f.v1.faces, f );\r\n\tif ( f.v2 ) removeFromArray( f.v2.faces, f );\r\n\tif ( f.v3 ) removeFromArray( f.v3.faces, f );\r\n\r\n\t// TODO optimize this!\r\n\tconst vs = [ f.v1, f.v2, f.v3 ];\r\n\r\n\tfor ( let i = 0; i < 3; i ++ ) {\r\n\r\n\t\tconst v1 = vs[ i ];\r\n\t\tconst v2 = vs[ ( i + 1 ) % 3 ];\r\n\r\n\t\tif ( ! v1 || ! v2 ) continue;\r\n\r\n\t\tv1.removeIfNonNeighbor( v2 );\r\n\t\tv2.removeIfNonNeighbor( v1 );\r\n\r\n\t}\r\n\r\n}\r\n\r\nfunction collapse( vertices, faces, u, v ) {\r\n\r\n\t// Collapse the edge uv by moving vertex u onto v\r\n\r\n\tif ( ! v ) {\r\n\r\n\t\t// u is a vertex all by itself so just delete it..\r\n\t\tremoveVertex( u, vertices );\r\n\t\treturn;\r\n\r\n\t}\r\n\r\n\tif ( v.uv ) {\r\n\r\n\t\tu.uv.copy( v.uv );\r\n\r\n\t}\r\n\r\n\tif ( v.normal ) {\r\n\r\n\t\tv.normal.add( u.normal ).normalize();\r\n\r\n\t}\r\n\r\n\tif ( v.tangent ) {\r\n\r\n\t\tv.tangent.add( u.tangent ).normalize();\r\n\r\n\t}\r\n\r\n\tconst tmpVertices = [];\r\n\r\n\tfor ( let i = 0; i < u.neighbors.length; i ++ ) {\r\n\r\n\t\ttmpVertices.push( u.neighbors[ i ] );\r\n\r\n\t}\r\n\r\n\r\n\t// delete triangles on edge uv:\r\n\tfor ( let i = u.faces.length - 1; i >= 0; i -- ) {\r\n\r\n\t\tif ( u.faces[ i ] && u.faces[ i ].hasVertex( v ) ) {\r\n\r\n\t\t\tremoveFace( u.faces[ i ], faces );\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\t// update remaining triangles to have v instead of u\r\n\tfor ( let i = u.faces.length - 1; i >= 0; i -- ) {\r\n\r\n\t\tu.faces[ i ].replaceVertex( u, v );\r\n\r\n\t}\r\n\r\n\r\n\tremoveVertex( u, vertices );\r\n\r\n\t// recompute the edge collapse costs in neighborhood\r\n\tfor ( let i = 0; i < tmpVertices.length; i ++ ) {\r\n\r\n\t\tcomputeEdgeCostAtVertex( tmpVertices[ i ] );\r\n\r\n\t}\r\n\r\n}\r\n\r\n\r\n\r\nfunction minimumCostEdge( vertices ) {\r\n\r\n\t// O(n * n) approach. TODO optimize this\r\n\r\n\tlet least = vertices[ 0 ];\r\n\r\n\tfor ( let i = 0; i < vertices.length; i ++ ) {\r\n\r\n\t\tif ( vertices[ i ].collapseCost < least.collapseCost ) {\r\n\r\n\t\t\tleast = vertices[ i ];\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\treturn least;\r\n\r\n}\r\n\r\n// we use a triangle class to represent structure of face slightly differently\r\n\r\nclass Triangle {\r\n\r\n\tconstructor( v1, v2, v3, a, b, c ) {\r\n\r\n\t\tthis.a = a;\r\n\t\tthis.b = b;\r\n\t\tthis.c = c;\r\n\r\n\t\tthis.v1 = v1;\r\n\t\tthis.v2 = v2;\r\n\t\tthis.v3 = v3;\r\n\r\n\t\tthis.normal = new Vector3();\r\n\r\n\t\tthis.computeNormal();\r\n\r\n\t\tv1.faces.push( this );\r\n\t\tv1.addUniqueNeighbor( v2 );\r\n\t\tv1.addUniqueNeighbor( v3 );\r\n\r\n\t\tv2.faces.push( this );\r\n\t\tv2.addUniqueNeighbor( v1 );\r\n\t\tv2.addUniqueNeighbor( v3 );\r\n\r\n\r\n\t\tv3.faces.push( this );\r\n\t\tv3.addUniqueNeighbor( v1 );\r\n\t\tv3.addUniqueNeighbor( v2 );\r\n\r\n\t}\r\n\r\n\tcomputeNormal() {\r\n\r\n\t\tconst vA = this.v1.position;\r\n\t\tconst vB = this.v2.position;\r\n\t\tconst vC = this.v3.position;\r\n\r\n\t\t_cb.subVectors( vC, vB );\r\n\t\t_ab.subVectors( vA, vB );\r\n\t\t_cb.cross( _ab ).normalize();\r\n\r\n\t\tthis.normal.copy( _cb );\r\n\r\n\t}\r\n\r\n\thasVertex( v ) {\r\n\r\n\t\treturn v === this.v1 || v === this.v2 || v === this.v3;\r\n\r\n\t}\r\n\r\n\treplaceVertex( oldv, newv ) {\r\n\r\n\t\tif ( oldv === this.v1 ) this.v1 = newv;\r\n\t\telse if ( oldv === this.v2 ) this.v2 = newv;\r\n\t\telse if ( oldv === this.v3 ) this.v3 = newv;\r\n\r\n\t\tremoveFromArray( oldv.faces, this );\r\n\t\tnewv.faces.push( this );\r\n\r\n\r\n\t\toldv.removeIfNonNeighbor( this.v1 );\r\n\t\tthis.v1.removeIfNonNeighbor( oldv );\r\n\r\n\t\toldv.removeIfNonNeighbor( this.v2 );\r\n\t\tthis.v2.removeIfNonNeighbor( oldv );\r\n\r\n\t\toldv.removeIfNonNeighbor( this.v3 );\r\n\t\tthis.v3.removeIfNonNeighbor( oldv );\r\n\r\n\t\tthis.v1.addUniqueNeighbor( this.v2 );\r\n\t\tthis.v1.addUniqueNeighbor( this.v3 );\r\n\r\n\t\tthis.v2.addUniqueNeighbor( this.v1 );\r\n\t\tthis.v2.addUniqueNeighbor( this.v3 );\r\n\r\n\t\tthis.v3.addUniqueNeighbor( this.v1 );\r\n\t\tthis.v3.addUniqueNeighbor( this.v2 );\r\n\r\n\t\tthis.computeNormal();\r\n\r\n\t}\r\n\r\n}\r\n\r\nclass Vertex {\r\n\r\n\tconstructor( v, uv, normal, tangent, color ) {\r\n\r\n\t\tthis.position = v;\r\n\t\tthis.uv = uv;\r\n\t\tthis.normal = normal;\r\n\t\tthis.tangent = tangent;\r\n\t\tthis.color = color;\r\n\r\n\t\tthis.id = - 1; // external use position in vertices list (for e.g. face generation)\r\n\r\n\t\tthis.faces = []; // faces vertex is connected\r\n\t\tthis.neighbors = []; // neighbouring vertices aka \"adjacentVertices\"\r\n\r\n\t\t// these will be computed in computeEdgeCostAtVertex()\r\n\t\tthis.collapseCost = 0; // cost of collapsing this vertex, the less the better. aka objdist\r\n\t\tthis.collapseNeighbor = null; // best candinate for collapsing\r\n\r\n\t}\r\n\r\n\taddUniqueNeighbor( vertex ) {\r\n\r\n\t\tpushIfUnique( this.neighbors, vertex );\r\n\r\n\t}\r\n\r\n\tremoveIfNonNeighbor( n ) {\r\n\r\n\t\tconst neighbors = this.neighbors;\r\n\t\tconst faces = this.faces;\r\n\r\n\t\tconst offset = neighbors.indexOf( n );\r\n\r\n\t\tif ( offset === - 1 ) return;\r\n\r\n\t\tfor ( let i = 0; i < faces.length; i ++ ) {\r\n\r\n\t\t\tif ( faces[ i ].hasVertex( n ) ) return;\r\n\r\n\t\t}\r\n\r\n\t\tneighbors.splice( offset, 1 );\r\n\r\n\t}\r\n\r\n}\r\n\r\nexport { SimplifyModifier };\r\n"],
  "mappings": "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",
  "names": []
}
