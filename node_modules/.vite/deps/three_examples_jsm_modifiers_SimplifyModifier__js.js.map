{
  "version": 3,
  "sources": ["../../three/examples/jsm/modifiers/SimplifyModifier.js"],
  "sourcesContent": ["// import {\r\n// \tBufferGeometry,\r\n// \tFloat32BufferAttribute,\r\n// \tVector2,\r\n// \tVector3,\r\n// \tVector4\r\n// } from 'three';\r\n// import * as BufferGeometryUtils from '../utils/BufferGeometryUtils.js';\r\n\r\n// /**\r\n//  *\tSimplification Geometry Modifier\r\n//  *    - based on code and technique\r\n//  *\t  - by Stan Melax in 1998\r\n//  *\t  - Progressive Mesh type Polygon Reduction Algorithm\r\n//  *    - http://www.melax.com/polychop/\r\n//  */\r\n\r\n// const _cb = new Vector3(), _ab = new Vector3();\r\n\r\n// class SimplifyModifier {\r\n\r\n// \tmodify( geometry, count ) {\r\n\r\n// \t\tgeometry = geometry.clone();\r\n\r\n// \t\t// currently morphAttributes are not supported\r\n// \t\tdelete geometry.morphAttributes.position;\r\n// \t\tdelete geometry.morphAttributes.normal;\r\n// \t\tconst attributes = geometry.attributes;\r\n\r\n// \t\t// this modifier can only process indexed and non-indexed geomtries with at least a position attribute\r\n\r\n// \t\tfor ( const name in attributes ) {\r\n\r\n// \t\t\tif ( name !== 'position' && name !== 'uv' && name !== 'normal' && name !== 'tangent' && name !== 'color' ) geometry.deleteAttribute( name );\r\n\r\n// \t\t}\r\n\r\n// \t\tgeometry = BufferGeometryUtils.mergeVertices( geometry );\r\n\r\n// \t\t//\r\n// \t\t// put data of original geometry in different data structures\r\n// \t\t//\r\n\r\n// \t\tconst vertices = [];\r\n// \t\tconst faces = [];\r\n\r\n// \t\t// add vertices\r\n\r\n// \t\tconst positionAttribute = geometry.getAttribute( 'position' );\r\n// \t\tconst uvAttribute = geometry.getAttribute( 'uv' );\r\n// \t\tconst normalAttribute = geometry.getAttribute( 'normal' );\r\n// \t\tconst tangentAttribute = geometry.getAttribute( 'tangent' );\r\n// \t\tconst colorAttribute = geometry.getAttribute( 'color' );\r\n\r\n// \t\tlet t = null;\r\n// \t\tlet v2 = null;\r\n// \t\tlet nor = null;\r\n// \t\tlet col = null;\r\n\r\n// \t\tfor ( let i = 0; i < positionAttribute.count; i ++ ) {\r\n\r\n// \t\t\tconst v = new Vector3().fromBufferAttribute( positionAttribute, i );\r\n// \t\t\tif ( uvAttribute ) {\r\n\r\n// \t\t\t\tv2 = new Vector2().fromBufferAttribute( uvAttribute, i );\r\n\r\n// \t\t\t}\r\n\r\n// \t\t\tif ( normalAttribute ) {\r\n\r\n// \t\t\t\tnor = new Vector3().fromBufferAttribute( normalAttribute, i );\r\n\r\n// \t\t\t}\r\n\r\n// \t\t\tif ( tangentAttribute ) {\r\n\r\n// \t\t\t\tt = new Vector4().fromBufferAttribute( tangentAttribute, i );\r\n\r\n// \t\t\t}\r\n\r\n// \t\t\tif ( colorAttribute ) {\r\n\r\n// \t\t\t\tcol = new THREE.Color().fromBufferAttribute( colorAttribute, i );\r\n\r\n// \t\t\t}\r\n\r\n// \t\t\tconst vertex = new Vertex( v, v2, nor, t, col );\r\n// \t\t\tvertices.push( vertex );\r\n\r\n// \t\t}\r\n\r\n// \t\t// add faces\r\n\r\n// \t\tlet index = geometry.getIndex();\r\n\r\n// \t\tif ( index !== null ) {\r\n\r\n// \t\t\tfor ( let i = 0; i < index.count; i += 3 ) {\r\n\r\n// \t\t\t\tconst a = index.getX( i );\r\n// \t\t\t\tconst b = index.getX( i + 1 );\r\n// \t\t\t\tconst c = index.getX( i + 2 );\r\n\r\n// \t\t\t\tconst triangle = new Triangle( vertices[ a ], vertices[ b ], vertices[ c ], a, b, c );\r\n// \t\t\t\tfaces.push( triangle );\r\n\r\n// \t\t\t}\r\n\r\n// \t\t} else {\r\n\r\n// \t\t\tfor ( let i = 0; i < positionAttribute.count; i += 3 ) {\r\n\r\n// \t\t\t\tconst a = i;\r\n// \t\t\t\tconst b = i + 1;\r\n// \t\t\t\tconst c = i + 2;\r\n\r\n// \t\t\t\tconst triangle = new Triangle( vertices[ a ], vertices[ b ], vertices[ c ], a, b, c );\r\n// \t\t\t\tfaces.push( triangle );\r\n\r\n// \t\t\t}\r\n\r\n// \t\t}\r\n\r\n// \t\t// compute all edge collapse costs\r\n\r\n// \t\tfor ( let i = 0, il = vertices.length; i < il; i ++ ) {\r\n\r\n// \t\t\tcomputeEdgeCostAtVertex( vertices[ i ] );\r\n\r\n// \t\t}\r\n\r\n// \t\tlet nextVertex;\r\n\r\n// \t\tlet z = count;\r\n\r\n// \t\twhile ( z -- ) {\r\n\r\n// \t\t\tnextVertex = minimumCostEdge( vertices );\r\n\r\n// \t\t\tif ( ! nextVertex ) {\r\n\r\n// \t\t\t\tconsole.log( 'THREE.SimplifyModifier: No next vertex' );\r\n// \t\t\t\tbreak;\r\n\r\n// \t\t\t}\r\n\r\n// \t\t\tcollapse( vertices, faces, nextVertex, nextVertex.collapseNeighbor );\r\n\r\n// \t\t}\r\n\r\n// \t\t//\r\n\r\n// \t\tconst simplifiedGeometry = new BufferGeometry();\r\n// \t\tconst position = [];\r\n// \t\tconst uv = [];\r\n// \t\tconst normal = [];\r\n// \t\tconst tangent = [];\r\n// \t\tconst color = [];\r\n\r\n// \t\tindex = [];\r\n\r\n// \t\t//\r\n\r\n// \t\tfor ( let i = 0; i < vertices.length; i ++ ) {\r\n\r\n// \t\t\tconst vertex = vertices[ i ];\r\n// \t\t\tposition.push( vertex.position.x, vertex.position.y, vertex.position.z );\r\n// \t\t\tif ( vertex.uv ) {\r\n\r\n// \t\t\t\tuv.push( vertex.uv.x, vertex.uv.y );\r\n\r\n// \t\t\t}\r\n\r\n// \t\t\tif ( vertex.normal ) {\r\n\r\n// \t\t\t\tnormal.push( vertex.normal.x, vertex.normal.y, vertex.normal.z );\r\n\r\n// \t\t\t}\r\n\r\n// \t\t\tif ( vertex.tangent ) {\r\n\r\n// \t\t\t\ttangent.push( vertex.tangent.x, vertex.tangent.y, vertex.tangent.z, vertex.tangent.w );\r\n\r\n// \t\t\t}\r\n\r\n// \t\t\tif ( vertex.color ) {\r\n\r\n// \t\t\t\tcolor.push( vertex.color.r, vertex.color.g, vertex.color.b );\r\n\r\n// \t\t\t}\r\n\r\n\r\n// \t\t\t// cache final index to GREATLY speed up faces reconstruction\r\n// \t\t\tvertex.id = i;\r\n\r\n// \t\t}\r\n\r\n// \t\t//\r\n\r\n// \t\tfor ( let i = 0; i < faces.length; i ++ ) {\r\n\r\n// \t\t\tconst face = faces[ i ];\r\n// \t\t\tindex.push( face.v1.id, face.v2.id, face.v3.id );\r\n\r\n// \t\t}\r\n\r\n// \t\tsimplifiedGeometry.setAttribute( 'position', new Float32BufferAttribute( position, 3 ) );\r\n// \t\tif ( uv.length > 0 ) simplifiedGeometry.setAttribute( 'uv', new Float32BufferAttribute( uv, 2 ) );\r\n// \t\tif ( normal.length > 0 ) simplifiedGeometry.setAttribute( 'normal', new Float32BufferAttribute( normal, 3 ) );\r\n// \t\tif ( tangent.length > 0 ) simplifiedGeometry.setAttribute( 'tangent', new Float32BufferAttribute( tangent, 4 ) );\r\n// \t\tif ( color.length > 0 ) simplifiedGeometry.setAttribute( 'color', new Float32BufferAttribute( color, 3 ) );\r\n\r\n// \t\tsimplifiedGeometry.setIndex( index );\r\n\r\n// \t\treturn simplifiedGeometry;\r\n\r\n// \t}\r\n\r\n// }\r\n\r\n// function pushIfUnique( array, object ) {\r\n\r\n// \tif ( array.indexOf( object ) === - 1 ) array.push( object );\r\n\r\n// }\r\n\r\n// function removeFromArray( array, object ) {\r\n\r\n// \tconst k = array.indexOf( object );\r\n// \tif ( k > - 1 ) array.splice( k, 1 );\r\n\r\n// }\r\n\r\n// function computeEdgeCollapseCost( u, v ) {\r\n\r\n// \t// if we collapse edge uv by moving u to v then how\r\n// \t// much different will the model change, i.e. the \"error\".\r\n\r\n// \tconst edgelength = v.position.distanceTo( u.position );\r\n// \tlet curvature = 0;\r\n\r\n// \tconst sideFaces = [];\r\n\r\n// \t// find the \"sides\" triangles that are on the edge uv\r\n// \tfor ( let i = 0, il = u.faces.length; i < il; i ++ ) {\r\n\r\n// \t\tconst face = u.faces[ i ];\r\n\r\n// \t\tif ( face.hasVertex( v ) ) {\r\n\r\n// \t\t\tsideFaces.push( face );\r\n\r\n// \t\t}\r\n\r\n// \t}\r\n\r\n// \t// use the triangle facing most away from the sides\r\n// \t// to determine our curvature term\r\n// \tfor ( let i = 0, il = u.faces.length; i < il; i ++ ) {\r\n\r\n// \t\tlet minCurvature = 1;\r\n// \t\tconst face = u.faces[ i ];\r\n\r\n// \t\tfor ( let j = 0; j < sideFaces.length; j ++ ) {\r\n\r\n// \t\t\tconst sideFace = sideFaces[ j ];\r\n// \t\t\t// use dot product of face normals.\r\n// \t\t\tconst dotProd = face.normal.dot( sideFace.normal );\r\n// \t\t\tminCurvature = Math.min( minCurvature, ( 1.001 - dotProd ) / 2 );\r\n\r\n// \t\t}\r\n\r\n// \t\tcurvature = Math.max( curvature, minCurvature );\r\n\r\n// \t}\r\n\r\n// \t// crude approach in attempt to preserve borders\r\n// \t// though it seems not to be totally correct\r\n// \tconst borders = 0;\r\n\r\n// \tif ( sideFaces.length < 2 ) {\r\n\r\n// \t\t// we add some arbitrary cost for borders,\r\n// \t\t// borders += 10;\r\n// \t\tcurvature = 1;\r\n\r\n// \t}\r\n\r\n// \tconst amt = edgelength * curvature + borders;\r\n\r\n// \treturn amt;\r\n\r\n// }\r\n\r\n// function computeEdgeCostAtVertex( v ) {\r\n\r\n// \t// compute the edge collapse cost for all edges that start\r\n// \t// from vertex v.  Since we are only interested in reducing\r\n// \t// the object by selecting the min cost edge at each step, we\r\n// \t// only cache the cost of the least cost edge at this vertex\r\n// \t// (in member variable collapse) as well as the value of the\r\n// \t// cost (in member variable collapseCost).\r\n\r\n// \tif ( v.neighbors.length === 0 ) {\r\n\r\n// \t\t// collapse if no neighbors.\r\n// \t\tv.collapseNeighbor = null;\r\n// \t\tv.collapseCost = - 0.01;\r\n\r\n// \t\treturn;\r\n\r\n// \t}\r\n\r\n// \tv.collapseCost = 100000;\r\n// \tv.collapseNeighbor = null;\r\n\r\n// \t// search all neighboring edges for \"least cost\" edge\r\n// \tfor ( let i = 0; i < v.neighbors.length; i ++ ) {\r\n\r\n// \t\tconst collapseCost = computeEdgeCollapseCost( v, v.neighbors[ i ] );\r\n\r\n// \t\tif ( ! v.collapseNeighbor ) {\r\n\r\n// \t\t\tv.collapseNeighbor = v.neighbors[ i ];\r\n// \t\t\tv.collapseCost = collapseCost;\r\n// \t\t\tv.minCost = collapseCost;\r\n// \t\t\tv.totalCost = 0;\r\n// \t\t\tv.costCount = 0;\r\n\r\n// \t\t}\r\n\r\n// \t\tv.costCount ++;\r\n// \t\tv.totalCost += collapseCost;\r\n\r\n// \t\tif ( collapseCost < v.minCost ) {\r\n\r\n// \t\t\tv.collapseNeighbor = v.neighbors[ i ];\r\n// \t\t\tv.minCost = collapseCost;\r\n\r\n// \t\t}\r\n\r\n// \t}\r\n\r\n// \t// we average the cost of collapsing at this vertex\r\n// \tv.collapseCost = v.totalCost / v.costCount;\r\n// \t// v.collapseCost = v.minCost;\r\n\r\n// }\r\n\r\n// function removeVertex( v, vertices ) {\r\n\r\n// \tconsole.assert( v.faces.length === 0 );\r\n\r\n// \twhile ( v.neighbors.length ) {\r\n\r\n// \t\tconst n = v.neighbors.pop();\r\n// \t\tremoveFromArray( n.neighbors, v );\r\n\r\n// \t}\r\n\r\n// \tremoveFromArray( vertices, v );\r\n\r\n// }\r\n\r\n// function removeFace( f, faces ) {\r\n\r\n// \tremoveFromArray( faces, f );\r\n\r\n// \tif ( f.v1 ) removeFromArray( f.v1.faces, f );\r\n// \tif ( f.v2 ) removeFromArray( f.v2.faces, f );\r\n// \tif ( f.v3 ) removeFromArray( f.v3.faces, f );\r\n\r\n// \t// TODO optimize this!\r\n// \tconst vs = [ f.v1, f.v2, f.v3 ];\r\n\r\n// \tfor ( let i = 0; i < 3; i ++ ) {\r\n\r\n// \t\tconst v1 = vs[ i ];\r\n// \t\tconst v2 = vs[ ( i + 1 ) % 3 ];\r\n\r\n// \t\tif ( ! v1 || ! v2 ) continue;\r\n\r\n// \t\tv1.removeIfNonNeighbor( v2 );\r\n// \t\tv2.removeIfNonNeighbor( v1 );\r\n\r\n// \t}\r\n\r\n// }\r\n\r\n// function collapse( vertices, faces, u, v ) {\r\n\r\n// \t// Collapse the edge uv by moving vertex u onto v\r\n\r\n// \tif ( ! v ) {\r\n\r\n// \t\t// u is a vertex all by itself so just delete it..\r\n// \t\tremoveVertex( u, vertices );\r\n// \t\treturn;\r\n\r\n// \t}\r\n\r\n// \tif ( v.uv ) {\r\n\r\n// \t\tu.uv.copy( v.uv );\r\n\r\n// \t}\r\n\r\n// \tif ( v.normal ) {\r\n\r\n// \t\tv.normal.add( u.normal ).normalize();\r\n\r\n// \t}\r\n\r\n// \tif ( v.tangent ) {\r\n\r\n// \t\tv.tangent.add( u.tangent ).normalize();\r\n\r\n// \t}\r\n\r\n// \tconst tmpVertices = [];\r\n\r\n// \tfor ( let i = 0; i < u.neighbors.length; i ++ ) {\r\n\r\n// \t\ttmpVertices.push( u.neighbors[ i ] );\r\n\r\n// \t}\r\n\r\n\r\n// \t// delete triangles on edge uv:\r\n// \tfor ( let i = u.faces.length - 1; i >= 0; i -- ) {\r\n\r\n// \t\tif ( u.faces[ i ] && u.faces[ i ].hasVertex( v ) ) {\r\n\r\n// \t\t\tremoveFace( u.faces[ i ], faces );\r\n\r\n// \t\t}\r\n\r\n// \t}\r\n\r\n// \t// update remaining triangles to have v instead of u\r\n// \tfor ( let i = u.faces.length - 1; i >= 0; i -- ) {\r\n\r\n// \t\tu.faces[ i ].replaceVertex( u, v );\r\n\r\n// \t}\r\n\r\n\r\n// \tremoveVertex( u, vertices );\r\n\r\n// \t// recompute the edge collapse costs in neighborhood\r\n// \tfor ( let i = 0; i < tmpVertices.length; i ++ ) {\r\n\r\n// \t\tcomputeEdgeCostAtVertex( tmpVertices[ i ] );\r\n\r\n// \t}\r\n\r\n// }\r\n\r\n\r\n\r\n// function minimumCostEdge( vertices ) {\r\n\r\n// \t// O(n * n) approach. TODO optimize this\r\n\r\n// \tlet least = vertices[ 0 ];\r\n\r\n// \tfor ( let i = 0; i < vertices.length; i ++ ) {\r\n\r\n// \t\tif ( vertices[ i ].collapseCost < least.collapseCost ) {\r\n\r\n// \t\t\tleast = vertices[ i ];\r\n\r\n// \t\t}\r\n\r\n// \t}\r\n\r\n// \treturn least;\r\n\r\n// }\r\n\r\n// // we use a triangle class to represent structure of face slightly differently\r\n\r\n// class Triangle {\r\n\r\n// \tconstructor( v1, v2, v3, a, b, c ) {\r\n\r\n// \t\tthis.a = a;\r\n// \t\tthis.b = b;\r\n// \t\tthis.c = c;\r\n\r\n// \t\tthis.v1 = v1;\r\n// \t\tthis.v2 = v2;\r\n// \t\tthis.v3 = v3;\r\n\r\n// \t\tthis.normal = new Vector3();\r\n\r\n// \t\tthis.computeNormal();\r\n\r\n// \t\tv1.faces.push( this );\r\n// \t\tv1.addUniqueNeighbor( v2 );\r\n// \t\tv1.addUniqueNeighbor( v3 );\r\n\r\n// \t\tv2.faces.push( this );\r\n// \t\tv2.addUniqueNeighbor( v1 );\r\n// \t\tv2.addUniqueNeighbor( v3 );\r\n\r\n\r\n// \t\tv3.faces.push( this );\r\n// \t\tv3.addUniqueNeighbor( v1 );\r\n// \t\tv3.addUniqueNeighbor( v2 );\r\n\r\n// \t}\r\n\r\n// \tcomputeNormal() {\r\n\r\n// \t\tconst vA = this.v1.position;\r\n// \t\tconst vB = this.v2.position;\r\n// \t\tconst vC = this.v3.position;\r\n\r\n// \t\t_cb.subVectors( vC, vB );\r\n// \t\t_ab.subVectors( vA, vB );\r\n// \t\t_cb.cross( _ab ).normalize();\r\n\r\n// \t\tthis.normal.copy( _cb );\r\n\r\n// \t}\r\n\r\n// \thasVertex( v ) {\r\n\r\n// \t\treturn v === this.v1 || v === this.v2 || v === this.v3;\r\n\r\n// \t}\r\n\r\n// \treplaceVertex( oldv, newv ) {\r\n\r\n// \t\tif ( oldv === this.v1 ) this.v1 = newv;\r\n// \t\telse if ( oldv === this.v2 ) this.v2 = newv;\r\n// \t\telse if ( oldv === this.v3 ) this.v3 = newv;\r\n\r\n// \t\tremoveFromArray( oldv.faces, this );\r\n// \t\tnewv.faces.push( this );\r\n\r\n\r\n// \t\toldv.removeIfNonNeighbor( this.v1 );\r\n// \t\tthis.v1.removeIfNonNeighbor( oldv );\r\n\r\n// \t\toldv.removeIfNonNeighbor( this.v2 );\r\n// \t\tthis.v2.removeIfNonNeighbor( oldv );\r\n\r\n// \t\toldv.removeIfNonNeighbor( this.v3 );\r\n// \t\tthis.v3.removeIfNonNeighbor( oldv );\r\n\r\n// \t\tthis.v1.addUniqueNeighbor( this.v2 );\r\n// \t\tthis.v1.addUniqueNeighbor( this.v3 );\r\n\r\n// \t\tthis.v2.addUniqueNeighbor( this.v1 );\r\n// \t\tthis.v2.addUniqueNeighbor( this.v3 );\r\n\r\n// \t\tthis.v3.addUniqueNeighbor( this.v1 );\r\n// \t\tthis.v3.addUniqueNeighbor( this.v2 );\r\n\r\n// \t\tthis.computeNormal();\r\n\r\n// \t}\r\n\r\n// }\r\n\r\n// class Vertex {\r\n\r\n// \tconstructor( v, uv, normal, tangent, color ) {\r\n\r\n// \t\tthis.position = v;\r\n// \t\tthis.uv = uv;\r\n// \t\tthis.normal = normal;\r\n// \t\tthis.tangent = tangent;\r\n// \t\tthis.color = color;\r\n\r\n// \t\tthis.id = - 1; // external use position in vertices list (for e.g. face generation)\r\n\r\n// \t\tthis.faces = []; // faces vertex is connected\r\n// \t\tthis.neighbors = []; // neighbouring vertices aka \"adjacentVertices\"\r\n\r\n// \t\t// these will be computed in computeEdgeCostAtVertex()\r\n// \t\tthis.collapseCost = 0; // cost of collapsing this vertex, the less the better. aka objdist\r\n// \t\tthis.collapseNeighbor = null; // best candinate for collapsing\r\n\r\n// \t}\r\n\r\n// \taddUniqueNeighbor( vertex ) {\r\n\r\n// \t\tpushIfUnique( this.neighbors, vertex );\r\n\r\n// \t}\r\n\r\n// \tremoveIfNonNeighbor( n ) {\r\n\r\n// \t\tconst neighbors = this.neighbors;\r\n// \t\tconst faces = this.faces;\r\n\r\n// \t\tconst offset = neighbors.indexOf( n );\r\n\r\n// \t\tif ( offset === - 1 ) return;\r\n\r\n// \t\tfor ( let i = 0; i < faces.length; i ++ ) {\r\n\r\n// \t\t\tif ( faces[ i ].hasVertex( n ) ) return;\r\n\r\n// \t\t}\r\n\r\n// \t\tneighbors.splice( offset, 1 );\r\n\r\n// \t}\r\n\r\n// }\r\n\r\n// export { SimplifyModifier };\r\n\r\n\r\n\r\n\r\n\r\nimport * as THREE from 'three';\r\n\r\nconst cb = new THREE.Vector3();\r\nconst ab = new THREE.Vector3();\r\n\r\nclass SimplifyModifier {\r\n  constructor() {\r\n    this.lowerLimit = 51;\r\n  }\r\n\r\n  modify(geometryRaw, percentage, preserveTexture = true) {\r\n    let geometry = geometryRaw;\r\n    \r\n    if (geometry.vertices.length < this.lowerLimit * 3) {\r\n      return geometryRaw;\r\n    }\r\n\r\n    geometry.mergeVertices();\r\n    geometry.computeVertexNormals();\r\n\r\n    const oldVertices = geometry.vertices;\r\n    const oldFaces = geometry.faces;\r\n    const oldFaceUVs = geometry.faceVertexUvs[0];\r\n\r\n    const vertices = oldVertices.map((v, i) => new Vertex(v, i));\r\n    const faces = [];\r\n    const faceUVs = [];\r\n\r\n    if (preserveTexture && oldFaceUVs.length) {\r\n      for (const faceUV of oldFaceUVs) {\r\n        faceUVs.push([\r\n          new THREE.Vector2(faceUV[0].x, faceUV[0].y),\r\n          new THREE.Vector2(faceUV[1].x, faceUV[1].y),\r\n          new THREE.Vector2(faceUV[2].x, faceUV[2].y)\r\n        ]);\r\n      }\r\n    }\r\n\r\n    for (let i = 0; i < oldFaces.length; i++) {\r\n      const face = oldFaces[i];\r\n      faces.push(new Triangle(\r\n        vertices[face.a],\r\n        vertices[face.b],\r\n        vertices[face.c],\r\n        face.a,\r\n        face.b,\r\n        face.c,\r\n        faceUVs[i],\r\n        face.materialIndex\r\n      ));\r\n    }\r\n\r\n    vertices.forEach(vertex => computeEdgeCostAtVertex(vertex));\r\n\r\n    let z = Math.round(geometry.vertices.length * percentage);\r\n    let skip = 0;\r\n\r\n    while (z--) {\r\n      const nextVertex = minimumCostEdge(vertices, skip);\r\n      if (!nextVertex) {\r\n        console.log(\"no next vertex\");\r\n        break;\r\n      }\r\n\r\n      const collapsed = collapse(\r\n        vertices,\r\n        faces,\r\n        nextVertex,\r\n        nextVertex.collapseNeighbor,\r\n        preserveTexture\r\n      );\r\n      if (!collapsed) {\r\n        skip++;\r\n      }\r\n    }\r\n\r\n    const newGeo = new THREE.Geometry();\r\n    if (preserveTexture && oldFaceUVs.length) newGeo.faceVertexUvs[0] = [];\r\n\r\n    vertices.forEach(v => newGeo.vertices.push(v.position));\r\n\r\n    faces.forEach(tri => {\r\n      newGeo.faces.push(\r\n        new THREE.Face3(\r\n          vertices.indexOf(tri.v1),\r\n          vertices.indexOf(tri.v2),\r\n          vertices.indexOf(tri.v3),\r\n          undefined,\r\n          undefined,\r\n          tri.materialIndex\r\n        )\r\n      );\r\n\r\n      if (preserveTexture && oldFaceUVs.length) {\r\n        newGeo.faceVertexUvs[0].push(tri.faceVertexUvs);\r\n      }\r\n    });\r\n\r\n    newGeo.mergeVertices();\r\n    newGeo.computeVertexNormals();\r\n    newGeo.computeFaceNormals();\r\n    newGeo.name = geometry.name;\r\n\r\n    return newGeo;\r\n  }\r\n}\r\n\r\nclass Triangle {\r\n  constructor(v1, v2, v3, a, b, c, fvuv, materialIndex) {\r\n    this.a = a;\r\n    this.b = b;\r\n    this.c = c;\r\n    this.v1 = v1;\r\n    this.v2 = v2;\r\n    this.v3 = v3;\r\n    this.normal = new THREE.Vector3();\r\n    this.faceVertexUvs = fvuv;\r\n    this.materialIndex = materialIndex;\r\n\r\n    this.computeNormal();\r\n\r\n    v1.faces.push(this);\r\n    v1.addUniqueNeighbor(v2);\r\n    v1.addUniqueNeighbor(v3);\r\n\r\n    v2.faces.push(this);\r\n    v2.addUniqueNeighbor(v1);\r\n    v2.addUniqueNeighbor(v3);\r\n\r\n    v3.faces.push(this);\r\n    v3.addUniqueNeighbor(v1);\r\n    v3.addUniqueNeighbor(v2);\r\n  }\r\n\r\n  computeNormal() {\r\n    const vA = this.v1.position;\r\n    const vB = this.v2.position;\r\n    const vC = this.v3.position;\r\n\r\n    cb.subVectors(vC, vB);\r\n    ab.subVectors(vA, vB);\r\n    cb.cross(ab).normalize();\r\n\r\n    this.normal.copy(cb);\r\n  }\r\n\r\n  hasVertex(v) {\r\n    return v === this.v1 || v === this.v2 || v === this.v3;\r\n  }\r\n\r\n  replaceVertex(oldv, newv) {\r\n    if (oldv === this.v1) {\r\n      this.a = newv.id;\r\n      this.v1 = newv;\r\n    } else if (oldv === this.v2) {\r\n      this.b = newv.id;\r\n      this.v2 = newv;\r\n    } else if (oldv === this.v3) {\r\n      this.c = newv.id;\r\n      this.v3 = newv;\r\n    }\r\n\r\n    removeFromArray(oldv.faces, this);\r\n    newv.faces.push(this);\r\n\r\n    oldv.removeIfNonNeighbor(this.v1);\r\n    this.v1.removeIfNonNeighbor(oldv);\r\n\r\n    oldv.removeIfNonNeighbor(this.v2);\r\n    this.v2.removeIfNonNeighbor(oldv);\r\n\r\n    oldv.removeIfNonNeighbor(this.v3);\r\n    this.v3.removeIfNonNeighbor(oldv);\r\n\r\n    this.v1.addUniqueNeighbor(this.v2);\r\n    this.v1.addUniqueNeighbor(this.v3);\r\n\r\n    this.v2.addUniqueNeighbor(this.v1);\r\n    this.v2.addUniqueNeighbor(this.v3);\r\n\r\n    this.v3.addUniqueNeighbor(this.v1);\r\n    this.v3.addUniqueNeighbor(this.v2);\r\n\r\n    this.computeNormal();\r\n  }\r\n}\r\n\r\nclass Vertex {\r\n  constructor(v, id) {\r\n    this.position = v;\r\n    this.id = id;\r\n    this.faces = [];\r\n    this.neighbors = [];\r\n    this.collapseCost = 0;\r\n    this.collapseNeighbor = null;\r\n  }\r\n\r\n  addUniqueNeighbor(vertex) {\r\n    pushIfUnique(this.neighbors, vertex);\r\n  }\r\n\r\n  removeIfNonNeighbor(n) {\r\n    const index = this.neighbors.indexOf(n);\r\n    if (index === -1) return;\r\n    for (const face of this.faces) {\r\n      if (face.hasVertex(n)) return;\r\n    }\r\n    this.neighbors.splice(index, 1);\r\n  }\r\n}\r\n\r\nfunction pushIfUnique(array, object) {\r\n  if (array.indexOf(object) === -1) array.push(object);\r\n}\r\n\r\nfunction removeFromArray(array, object) {\r\n  const index = array.indexOf(object);\r\n  if (index > -1) array.splice(index, 1);\r\n}\r\n\r\nfunction computeEdgeCollapseCost(u, v) {\r\n  const edgelength = v.position.distanceTo(u.position);\r\n  let curvature = 0;\r\n\r\n  const sideFaces = [];\r\n  for (const face of u.faces) {\r\n    if (face.hasVertex(v)) {\r\n      sideFaces.push(face);\r\n    }\r\n  }\r\n\r\n  for (const face of u.faces) {\r\n    let minCurvature = 1;\r\n    for (const sideFace of sideFaces) {\r\n      const dotProd = face.normal.dot(sideFace.normal);\r\n      minCurvature = Math.min(minCurvature, (1.001 - dotProd) / 2);\r\n    }\r\n    curvature = Math.max(curvature, minCurvature);\r\n  }\r\n\r\n  let borders = 0;\r\n  if (sideFaces.length < 2) {\r\n    curvature = 1;\r\n  }\r\n\r\n  const amt = edgelength * curvature + borders + computeUVsCost(u, v);\r\n\r\n  return amt;\r\n}\r\n\r\nfunction computeUVsCost(u, v) {\r\n  if (!u.faces[0].faceVertexUvs || !v.faces[0].faceVertexUvs) return 0;\r\n  let UVcost = 0;\r\n\r\n  const checkUVs = (vertex) => {\r\n    const UVsAroundVertex = vertex.faces\r\n      .filter(f => f.hasVertex(vertex === u ? v : u))\r\n      .map(f => getUVsOnVertex(f, vertex));\r\n\r\n    UVsAroundVertex.reduce((prev, uv) => {\r\n      if (prev.x && (prev.x !== uv.x || prev.y !== uv.y)) {\r\n        UVcost += 1;\r\n      }\r\n      return uv;\r\n    }, {});\r\n  };\r\n\r\n  checkUVs(v);\r\n  checkUVs(u);\r\n\r\n  return UVcost;\r\n}\r\n\r\nfunction computeEdgeCostAtVertex(v) {\r\n  if (v.neighbors.length === 0) {\r\n    v.collapseNeighbor = null;\r\n    v.collapseCost = -0.01;\r\n    return;\r\n  }\r\n\r\n  v.collapseCost = 100000;\r\n  v.collapseNeighbor = null;\r\n\r\n  for (const neighbor of v.neighbors) {\r\n    const collapseCost = computeEdgeCollapseCost(v, neighbor);\r\n\r\n    if (!v.collapseNeighbor) {\r\n      v.collapseNeighbor = neighbor;\r\n      v.collapseCost = collapseCost;\r\n      v.minCost = collapseCost;\r\n      v.totalCost = 0;\r\n      v.costCount = 0;\r\n    }\r\n\r\n    v.costCount++;\r\n    v.totalCost += collapseCost;\r\n\r\n    if (collapseCost < v.minCost) {\r\n      v.collapseNeighbor = neighbor;\r\n      v.minCost = collapseCost;\r\n    }\r\n  }\r\n\r\n  v.collapseCost = v.totalCost / v.costCount;\r\n}\r\n\r\nfunction collapse(vertices, faces, u, v, preserveTexture) {\r\n  if (!v) {\r\n    removeVertex(u, vertices);\r\n    return true;\r\n  }\r\n\r\n  const tmpVertices = [...u.neighbors];\r\n\r\n  let moveToThisUvsValues = null;\r\n\r\n  for (let i = u.faces.length - 1; i >= 0; i--) {\r\n    if (u.faces[i].hasVertex(v)) {\r\n      if (preserveTexture && u.faces[i].faceVertexUvs) {\r\n        moveToThisUvsValues = getUVsOnVertex(u.faces[i], v);\r\n      }\r\n      removeFace(u.faces[i], faces);\r\n    }\r\n  }\r\n\r\n  if (preserveTexture && u.faces.length && u.faces[0].faceVertexUvs) {\r\n    for (const face of u.faces) {\r\n      const faceVerticeUVs = getUVsOnVertex(face, u);\r\n      faceVerticeUVs.copy(moveToThisUvsValues);\r\n    }\r\n  }\r\n\r\n  for (const face of u.faces) {\r\n    face.replaceVertex(u, v);\r\n  }\r\n\r\n  removeVertex(u, vertices);\r\n\r\n  for (const vertex of tmpVertices) {\r\n    computeEdgeCostAtVertex(vertex);\r\n  }\r\n\r\n  return true;\r\n}\r\n\r\nfunction removeVertex(v, vertices) {\r\n  console.assert(v.faces.length === 0);\r\n  while (v.neighbors.length) {\r\n    const n = v.neighbors.pop();\r\n    removeFromArray(n.neighbors, v);\r\n  }\r\n  removeFromArray(vertices, v);\r\n}\r\n\r\nfunction removeFace(f, faces) {\r\n  removeFromArray(faces, f);\r\n  if (f.v1) removeFromArray(f.v1.faces, f);\r\n  if (f.v2) removeFromArray(f.v2.faces, f);\r\n  if (f.v3) removeFromArray(f.v3.faces, f);\r\n\r\n  const vs = [f.v1, f.v2, f.v3];\r\n  for (let i = 0; i < 3; i++) {\r\n    const v1 = vs[i];\r\n    const v2 = vs[(i + 1) % 3];\r\n    if (!v1 || !v2) continue;\r\n    v1.removeIfNonNeighbor(v2);\r\n    v2.removeIfNonNeighbor(v1);\r\n  }\r\n}\r\n\r\nfunction minimumCostEdge(vertices, skip) {\r\n  return vertices.slice(skip).reduce((least, current) => \r\n    current.collapseCost < least.collapseCost ? current : least\r\n  );\r\n}\r\n\r\nfunction getPointInBetweenByPerc(pointA, pointB, percentage) {\r\n  const dir = pointB.clone().sub(pointA);\r\n  const len = dir.length();\r\n  dir.normalize().multiplyScalar(len * percentage);\r\n  return pointA.clone().add(dir);\r\n}\r\n\r\nfunction getUVsOnVertex(face, vertex) {\r\n  return face.faceVertexUvs[getVertexIndexOnFace(face, vertex)];\r\n}\r\n\r\nfunction getVertexIndexOnFace(face, vertex) {\r\n  const index = [face.v1, face.v2, face.v3].indexOf(vertex);\r\n  if (index === -1) {\r\n    throw new Error(\"Vertex not found\");\r\n  }\r\n  return index;\r\n}\r\n\r\nexport { SimplifyModifier };"],
  "mappings": "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",
  "names": []
}
