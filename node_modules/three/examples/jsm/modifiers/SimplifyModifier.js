import * as THREE from 'three';

class SimplifyModifier {
  constructor() {
    this.lowerLimit = 51;
  }

  modify(bufferGeometry, percentage) {
    if (!bufferGeometry.isBufferGeometry) {
      console.error('SimplifyModifier: geometry is not a BufferGeometry instance.');
      return bufferGeometry;
    }

    const vertices = [];
    const faces = [];

    // Extract position attribute
    const positionAttribute = bufferGeometry.getAttribute('position');
    if (!positionAttribute) {
      console.error('SimplifyModifier: geometry has no position attribute.');
      return bufferGeometry;
    }

    // Convert buffer geometry to our internal data structure
    for (let i = 0; i < positionAttribute.count; i++) {
      const x = positionAttribute.getX(i);
      const y = positionAttribute.getY(i);
      const z = positionAttribute.getZ(i);
      vertices.push(new Vertex(new THREE.Vector3(x, y, z), i));
    }

    // Extract faces
    if (bufferGeometry.index !== null) {
      const index = bufferGeometry.index.array;
      for (let i = 0; i < index.length; i += 3) {
        const a = index[i];
        const b = index[i + 1];
        const c = index[i + 2];
        faces.push(new Triangle(vertices[a], vertices[b], vertices[c], a, b, c));
      }
    } else {
      for (let i = 0; i < positionAttribute.count; i += 3) {
        const a = i;
        const b = i + 1;
        const c = i + 2;
        faces.push(new Triangle(vertices[a], vertices[b], vertices[c], a, b, c));
      }
    }

    // Simplification process
    let targetCount = Math.round(vertices.length * percentage);
    if (targetCount < this.lowerLimit) {
      console.warn('SimplifyModifier: target vertex count is too low. Returning original geometry.');
      return bufferGeometry;
    }

    let removedVertices = 0;
    while (vertices.length > targetCount) {
      const nextVertex = this.getNextVertexToRemove(vertices);
      if (!nextVertex) break;

      if (this.collapse(vertices, faces, nextVertex, nextVertex.collapseNeighbor)) {
        removedVertices++;
      }
    }

    // Rebuild geometry
    const newPositions = [];
    const newIndices = [];

    vertices.forEach((v, i) => {
      v.id = i;
      newPositions.push(v.position.x, v.position.y, v.position.z);
    });

    faces.forEach(f => {
      newIndices.push(f.v1.id, f.v2.id, f.v3.id);
    });

    const newGeometry = new THREE.BufferGeometry();
    newGeometry.setAttribute('position', new THREE.Float32BufferAttribute(newPositions, 3));
    newGeometry.setIndex(newIndices);
    newGeometry.computeVertexNormals();

    return newGeometry;
  }

  getNextVertexToRemove(vertices) {
    let minCost = Infinity;
    let minVertex = null;

    for (const vertex of vertices) {
      if (vertex.collapseCost < minCost) {
        minCost = vertex.collapseCost;
        minVertex = vertex;
      }
    }

    return minVertex;
  }

  collapse(vertices, faces, u, v) {
    if (!v) {
      this.removeVertex(vertices, u);
      return true;
    }

    const tmpFaces = [];

    // Delete triangles
    for (let i = u.faces.length - 1; i >= 0; i--) {
      const face = u.faces[i];
      if (face.hasVertex(v)) {
        tmpFaces.push(face);
        this.removeFace(faces, face);
      }
    }

    // Update remaining triangles
    for (let i = u.faces.length - 1; i >= 0; i--) {
      const face = u.faces[i];
      face.replaceVertex(u, v);
    }

    this.removeVertex(vertices, u);

    // Recompute the edge collapse costs in neighborhood
    for (const vertex of v.neighbors) {
      this.computeEdgeCostAtVertex(vertex);
    }

    return true;
  }

  removeVertex(vertices, v) {
    for (const neighbor of v.neighbors) {
      const index = neighbor.neighbors.indexOf(v);
      if (index !== -1) neighbor.neighbors.splice(index, 1);
    }
    const index = vertices.indexOf(v);
    if (index !== -1) vertices.splice(index, 1);
  }

  removeFace(faces, f) {
    if (f.v1) this.removeFromArray(f.v1.faces, f);
    if (f.v2) this.removeFromArray(f.v2.faces, f);
    if (f.v3) this.removeFromArray(f.v3.faces, f);
    this.removeFromArray(faces, f);
  }

  removeFromArray(array, item) {
    const index = array.indexOf(item);
    if (index !== -1) array.splice(index, 1);
  }

  computeEdgeCostAtVertex(v) {
    v.collapseCost = Infinity;
    v.collapseNeighbor = null;

    if (v.neighbors.length === 0) {
      v.collapseCost = -0.01;
      return;
    }

    for (const neighbor of v.neighbors) {
      const cost = this.computeEdgeCollapseCost(v, neighbor);
      if (cost < v.collapseCost) {
        v.collapseCost = cost;
        v.collapseNeighbor = neighbor;
      }
    }
  }

  computeEdgeCollapseCost(u, v) {
    const edgeLength = u.position.distanceTo(v.position);
    let curvature = 0;

    const sideFaces = u.faces.filter(face => face.hasVertex(v));

    for (const face of u.faces) {
      let minCurvature = 1;
      for (const sideFace of sideFaces) {
        const dotProd = face.normal.dot(sideFace.normal);
        minCurvature = Math.min(minCurvature, (1.001 - dotProd) / 2);
      }
      curvature = Math.max(curvature, minCurvature);
    }

    // Border detection
    const borders = sideFaces.length < 2 ? 10 : 0;

    return edgeLength * curvature + borders;
  }
}

class Triangle {
  constructor(v1, v2, v3, a, b, c) {
    this.v1 = v1;
    this.v2 = v2;
    this.v3 = v3;
    this.a = a;
    this.b = b;
    this.c = c;
    this.normal = new THREE.Vector3();
    this.computeNormal();
    this.addToVertices();
  }

  addToVertices() {
    this.v1.faces.push(this);
    this.v2.faces.push(this);
    this.v3.faces.push(this);
    this.v1.addUniqueNeighbor(this.v2);
    this.v1.addUniqueNeighbor(this.v3);
    this.v2.addUniqueNeighbor(this.v1);
    this.v2.addUniqueNeighbor(this.v3);
    this.v3.addUniqueNeighbor(this.v1);
    this.v3.addUniqueNeighbor(this.v2);
  }

  computeNormal() {
    const cb = new THREE.Vector3();
    const ab = new THREE.Vector3();
    cb.subVectors(this.v3.position, this.v2.position);
    ab.subVectors(this.v1.position, this.v2.position);
    cb.cross(ab);
    cb.normalize();
    this.normal.copy(cb);
  }

  hasVertex(v) {
    return v === this.v1 || v === this.v2 || v === this.v3;
  }

  replaceVertex(oldv, newv) {
    if (oldv === this.v1) this.v1 = newv;
    else if (oldv === this.v2) this.v2 = newv;
    else if (oldv === this.v3) this.v3 = newv;
    this.removeFromVertex(oldv);
    newv.faces.push(this);
    this.computeNormal();
  }

  removeFromVertex(v) {
    const index = v.faces.indexOf(this);
    if (index !== -1) v.faces.splice(index, 1);
  }
}

class Vertex {
  constructor(v, id) {
    this.position = v;
    this.id = id; // old index id
    this.faces = []; // faces vertex is connected
    this.neighbors = []; // neighbouring vertices aka "adjacentVertices"
    this.collapseCost = 0; // cost of collapsing this vertex, the less the better
    this.collapseNeighbor = null; // best candidate for collapsing
  }

  addUniqueNeighbor(vertex) {
    if (this.neighbors.indexOf(vertex) === -1) this.neighbors.push(vertex);
  }
}

export { SimplifyModifier };